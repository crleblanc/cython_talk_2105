# ipython script to do timings on various cumsum implementations
from __future__ import print_function
import numpy as np
import py_laplace
import np_laplace
import cy_laplace
import cy_wrap_claplace

# TODO: Parallel version works great with big arrays, so plot how each one scales.

laplace_funcs = (
             #('pure Python', py_laplace.py_update),
             ('Numpy', np_laplace.num_update),
             ('Cython', cy_laplace.cy_update),
             ('Cython C wrapper', cy_wrap_claplace.cy_update_c_wrap),
             ('Cython parallel', cy_laplace.cy_update_parallel),
             )

dx = 0.1
dy = 0.1
dx2 = dx*dx
dy2 = dy*dy

for name, laplace_func in laplace_funcs:

    niter = 10
    array_shape = 200  # don't make it bigger than 20000, that's a massive array!
    work_array = np.zeros([array_shape, array_shape], dtype=np.float64)
    work_array[0] = 1.0

    print('%s (min=%f, max=%f): ' % (name, work_array.min(), work_array.max()), end='')
    #for x in range(niter):
    #    laplace_func(work_array, dx2, dy2)

    %timeit laplace_func(work_array, dx2, dy2)

    #from matplotlib import pyplot as plt
    #plt.imshow(work_array.astype('f4'))
    #plt.show()
